/**
 * Minified by jsDelivr using Terser v5.3.5.
 * Original file: /npm/plotty@0.4.7/src/plotty.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import { colorscales } from "./colorscales";
import { parse as parseArithmetics } from "./arithmetics-parser";
function hasOwnProperty(e, t) {
  return Object.prototype.hasOwnProperty.call(e, t);
}
function defaultFor(e, t) {
  return void 0 !== e ? e : t;
}
function create3DContext(e, t) {
  const a = ["webgl", "experimental-webgl"];
  let r = null;
  for (let o = 0; o < a.length; ++o) {
    try {
      r = e.getContext(a[o], t);
    } catch (e) {}
    if (r) break;
  }
  return r && r.getExtension("OES_texture_float") ? r : null;
}
function createProgram(e, t, a) {
  const r = e.createShader(e.VERTEX_SHADER);
  if ((e.shaderSource(r, t), e.compileShader(r), !e.getShaderParameter(r, e.COMPILE_STATUS)))
    throw new Error(e.getShaderInfoLog(r));
  const o = e.createShader(e.FRAGMENT_SHADER);
  if ((e.shaderSource(o, a), e.compileShader(o), !e.getShaderParameter(o, e.COMPILE_STATUS)))
    throw new Error(e.getShaderInfoLog(o));
  const i = e.createProgram();
  return e.attachShader(i, r), e.attachShader(i, o), e.linkProgram(i), i;
}
function setRectangle(e, t, a, r, o) {
  const i = t,
    n = t + r,
    s = a,
    l = a + o;
  e.bufferData(e.ARRAY_BUFFER, new Float32Array([i, s, n, s, i, l, i, l, n, s, n, l]), e.STATIC_DRAW);
}
function createDataset(e, t, a, r, o) {
  let i;
  return (
    e &&
      (e.viewport(0, 0, r, o),
      (i = e.createTexture()),
      e.bindTexture(e.TEXTURE_2D, i),
      e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE),
      e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE),
      e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.NEAREST),
      e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.NEAREST),
      e.texImage2D(e.TEXTURE_2D, 0, e.LUMINANCE, r, o, 0, e.LUMINANCE, e.FLOAT, new Float32Array(a))),
    { textureData: i, width: r, height: o, data: a, id: t }
  );
}
function destroyDataset(e, t) {
  e && e.deleteTexture(t.textureData);
}
function addColorScale(e, t, a) {
  if (t.length !== a.length) throw new Error("Invalid color scale.");
  colorscales[e] = { colors: t, positions: a };
}
function renderColorScaleToCanvas(e, t) {
  const a = colorscales[e];
  t.height = 1;
  const r = t.getContext("2d");
  if ("[object Object]" === Object.prototype.toString.call(a)) {
    t.width = 256;
    const e = r.createLinearGradient(0, 0, 256, 1);
    for (let t = 0; t < a.colors.length; ++t) e.addColorStop(a.positions[t], a.colors[t]);
    (r.fillStyle = e), r.fillRect(0, 0, 256, 1);
  } else {
    if ("[object Uint8Array]" !== Object.prototype.toString.call(a)) throw new Error("Color scale not defined.");
    {
      t.width = 256;
      const e = r.createImageData(256, 1);
      e.data.set(a), r.putImageData(e, 0, 0);
    }
  }
}
const vertexShaderSource =
    "\nattribute vec2 a_position;\nattribute vec2 a_texCoord;\nuniform mat3 u_matrix;\nuniform vec2 u_resolution;\nvarying vec2 v_texCoord;\nvoid main() {\n  // apply transformation matrix\n  vec2 position = (u_matrix * vec3(a_position, 1)).xy;\n  // convert the rectangle from pixels to 0.0 to 1.0\n  vec2 zeroToOne = position / u_resolution;\n  // convert from 0->1 to 0->2\n  vec2 zeroToTwo = zeroToOne * 2.0;\n  // convert from 0->2 to -1->+1 (clipspace)\n  vec2 clipSpace = zeroToTwo - 1.0;\n  gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);\n  // pass the texCoord to the fragment shader\n  // The GPU will interpolate this value between points.\n  v_texCoord = a_texCoord;\n}",
  fragmentShaderSource =
    "\nprecision mediump float;\n// our texture\nuniform sampler2D u_textureData;\nuniform sampler2D u_textureScale;\nuniform vec2 u_textureSize;\nuniform vec2 u_domain;\nuniform vec2 u_display_range;\nuniform bool u_apply_display_range;\nuniform float u_noDataValue;\nuniform bool u_clampLow;\nuniform bool u_clampHigh;\n// the texCoords passed in from the vertex shader.\nvarying vec2 v_texCoord;\nvoid main() {\n  vec2 onePixel = vec2(1.0, 1.0) / u_textureSize;\n  float value = texture2D(u_textureData, v_texCoord)[0];\n  if(value < -3.402823466e+38) // Check for possible NaN value\n    gl_FragColor = vec4(0.0, 0, 0, 0.0);\n  else if (value == u_noDataValue)\n    gl_FragColor = vec4(0.0, 0, 0, 0.0);\n  else if (u_apply_display_range && (value < u_display_range[0] || value >= u_display_range[1]))\n        gl_FragColor = vec4(0.0, 0, 0, 0.0);\n  else if ((!u_clampLow && value < u_domain[0]) || (!u_clampHigh && value > u_domain[1]))\n    gl_FragColor = vec4(0, 0, 0, 0);\n  else {\n    float normalisedValue = (value - u_domain[0]) / (u_domain[1] - u_domain[0]);\n    gl_FragColor = texture2D(u_textureScale, vec2(normalisedValue, 0));\n  }\n}";
class plot {
  constructor(e) {
    if (
      ((this.datasetCollection = {}),
      (this.currentDataset = null),
      this.setCanvas(e.canvas),
      defaultFor(e.useWebGL, !0))
    )
      if (null !== create3DContext(document.createElement("canvas"), { premultipliedAlpha: !1 })) {
        const e = create3DContext(this.canvas, { premultipliedAlpha: !1 });
        (this.gl = e),
          (this.program = createProgram(e, vertexShaderSource, fragmentShaderSource)),
          e.useProgram(this.program);
        const t = e.getAttribLocation(this.program, "a_texCoord");
        (this.texCoordBuffer = e.createBuffer()),
          e.bindBuffer(e.ARRAY_BUFFER, this.texCoordBuffer),
          e.bufferData(e.ARRAY_BUFFER, new Float32Array([0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1]), e.STATIC_DRAW),
          e.enableVertexAttribArray(t),
          e.vertexAttribPointer(t, 2, e.FLOAT, !1, 0, 0);
      } else this.ctx = this.canvas.getContext("2d");
    else this.ctx = this.canvas.getContext("2d");
    if (
      (e.colorScaleImage
        ? this.setColorScaleImage(e.colorScaleImage)
        : this.setColorScale(defaultFor(e.colorScale, "viridis")),
      this.setDomain(defaultFor(e.domain, [0, 1])),
      (this.displayRange = defaultFor(e.displayRange, [0, 1])),
      (this.applyDisplayRange = defaultFor(e.applyDisplayRange, !1)),
      this.setClamp(defaultFor(e.clampLow, !0), e.clampHigh),
      this.setNoDataValue(e.noDataValue),
      e.data)
    ) {
      const t = e.data.length;
      this.setData(e.data, defaultFor(e.width, e.data[t - 2]), defaultFor(e.height, e.data[t - 2]));
    }
    if (e.datasets)
      for (let t = 0; t < e.datasets.length; ++t) {
        const a = e.datasets[t];
        this.addDataset(a.id, a.data, a.width, a.height);
      }
    e.matrix ? (this.matrix = e.matrix) : (this.matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1]);
  }
  getData() {
    const e = this.currentDataset;
    if (!e) throw new Error("No dataset available.");
    return e.data;
  }
  atPoint(e, t) {
    const a = this.currentDataset;
    if (!a) throw new Error("No dataset available.");
    if (e >= a.width || t >= a.height) throw new Error("Coordinates are outside of image bounds.");
    return a.data[t * a.width + e];
  }
  setData(e, t, a) {
    this.currentDataset && null === this.currentDataset.id && destroyDataset(this.gl, this.currentDataset),
      (this.currentDataset = createDataset(this.gl, null, e, t, a));
  }
  addDataset(e, t, a, r) {
    if (this.datasetAvailable(e)) throw new Error(`There is already a dataset registered with id '${e}'`);
    (this.datasetCollection[e] = createDataset(this.gl, e, t, a, r)),
      this.currentDataset || (this.currentDataset = this.datasetCollection[e]);
  }
  setCurrentDataset(e) {
    if (!this.datasetAvailable(e)) throw new Error(`No such dataset registered: '${e}'`);
    this.currentDataset && null === this.currentDataset.id && destroyDataset(this.gl, this.currentDataset),
      (this.currentDataset = this.datasetCollection[e]);
  }
  removeDataset(e) {
    const t = this.datasetCollection[e];
    if (!t) throw new Error(`No such dataset registered: '${e}'`);
    destroyDataset(this.gl, t),
      this.currentDataset === t && (this.currentDataset = null),
      delete this.datasetCollection[e];
  }
  datasetAvailable(e) {
    return hasOwnProperty(this.datasetCollection, e);
  }
  getColorScaleImage() {
    return this.colorScaleImage;
  }
  setCanvas(e) {
    this.canvas = e || document.createElement("canvas");
  }
  setDomain(e) {
    if (!e || 2 !== e.length) throw new Error("Invalid domain specified.");
    this.domain = e;
  }
  setDisplayRange(e) {
    if (!e || 2 !== e.length) throw new Error("Invalid view range specified.");
    (this.displayRange = e), (this.applyDisplayRange = !0);
  }
  getCanvas() {
    return this.canvas;
  }
  setColorScale(e) {
    if (!hasOwnProperty(colorscales, e)) throw new Error(`No such color scale '${e}'`);
    this.colorScaleCanvas ||
      ((this.colorScaleCanvas = document.createElement("canvas")),
      (this.colorScaleCanvas.width = 256),
      (this.colorScaleCanvas.height = 1)),
      renderColorScaleToCanvas(e, this.colorScaleCanvas),
      (this.name = e),
      this.setColorScaleImage(this.colorScaleCanvas);
  }
  setClamp(e, t) {
    (this.clampLow = e), (this.clampHigh = void 0 !== t ? t : e);
  }
  setColorScaleImage(e) {
    this.colorScaleImage = e;
    const t = this.gl;
    t &&
      (this.textureScale && t.deleteTexture(this.textureScale),
      (this.textureScale = t.createTexture()),
      t.bindTexture(t.TEXTURE_2D, this.textureScale),
      t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE),
      t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE),
      t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.NEAREST),
      t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.NEAREST),
      t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, e));
  }
  setNoDataValue(e) {
    this.noDataValue = e;
  }
  render() {
    const e = this.canvas,
      t = this.currentDataset;
    (e.width = t.width), (e.height = t.height);
    let a = null;
    if (this.expressionAst) {
      const e = new Set([]),
        t = (a) => {
          "string" == typeof a && e.add(a.replace(new RegExp(/[+-]/, "g"), "")),
            "string" == typeof a.lhs
              ? e.add(a.lhs.replace(new RegExp(/[+-]/, "g"), ""))
              : "object" == typeof a.lhs && t(a.lhs),
            "string" == typeof a.rhs
              ? e.add(a.rhs.replace(new RegExp(/[+-]/, "g"), ""))
              : "object" == typeof a.rhs && t(a.rhs);
        };
      t(this.expressionAst), (a = Array.from(e));
    }
    let r = null;
    if (this.gl) {
      const o = this.gl;
      if ((o.viewport(0, 0, t.width, t.height), this.expressionAst)) {
        const e = (t) =>
            "object" == typeof t
              ? "**" === t.op
                ? `pow(${e(t.lhs)}, ${e(t.rhs)})`
                : t.fn
                ? `(${t.fn}(${e(t.lhs)}))`
                : `(${e(t.lhs)} ${t.op} ${e(t.rhs)})`
              : "string" == typeof t
              ? t + "_value"
              : `float(${t})`,
          t = e(this.expressionAst),
          i = `\n        precision mediump float;\n        // our texture\n        uniform sampler2D u_textureScale;\n\n        // add all required textures\n${a
            .map((e) => `        uniform sampler2D u_texture_${e};`)
            .join(
              "\n"
            )}\n\n        uniform vec2 u_textureSize;\n        uniform vec2 u_domain;\n        uniform float u_noDataValue;\n        uniform bool u_clampLow;\n        uniform bool u_clampHigh;\n        // the texCoords passed in from the vertex shader.\n        varying vec2 v_texCoord;\n        void main() {\n${a
            .map((e) => `          float ${e}_value = texture2D(u_texture_${e}, v_texCoord)[0];`)
            .join(
              "\n"
            )}\n          float value = ${t};\n\n          if (value == u_noDataValue)\n            gl_FragColor = vec4(0.0, 0, 0, 0.0);\n          else if ((!u_clampLow && value < u_domain[0]) || (!u_clampHigh && value > u_domain[1]))\n            gl_FragColor = vec4(0, 0, 0, 0);\n          else {\n            float normalisedValue = (value - u_domain[0]) / (u_domain[1] - u_domain[0]);\n            gl_FragColor = texture2D(u_textureScale, vec2(normalisedValue, 0));\n          }\n        }`;
        (r = createProgram(o, vertexShaderSource, i)),
          o.useProgram(r),
          o.uniform1i(o.getUniformLocation(r, "u_textureScale"), 0),
          o.activeTexture(o.TEXTURE0),
          o.bindTexture(o.TEXTURE_2D, this.textureScale);
        for (let e = 0; e < a.length; ++e) {
          const t = e + 1,
            i = a[e],
            n = this.datasetCollection[i];
          if (!n) throw new Error(`No such dataset registered: '${i}'`);
          o.uniform1i(o.getUniformLocation(r, "u_texture_" + i), t),
            o.activeTexture(o["TEXTURE" + t]),
            o.bindTexture(o.TEXTURE_2D, n.textureData);
        }
      } else
        (r = this.program),
          o.useProgram(r),
          o.uniform1i(o.getUniformLocation(r, "u_textureData"), 0),
          o.uniform1i(o.getUniformLocation(r, "u_textureScale"), 1),
          o.activeTexture(o.TEXTURE0),
          o.bindTexture(o.TEXTURE_2D, t.textureData),
          o.activeTexture(o.TEXTURE1),
          o.bindTexture(o.TEXTURE_2D, this.textureScale);
      const i = o.getAttribLocation(r, "a_position"),
        n = o.getUniformLocation(r, "u_domain"),
        s = o.getUniformLocation(r, "u_display_range"),
        l = o.getUniformLocation(r, "u_apply_display_range"),
        c = o.getUniformLocation(r, "u_resolution"),
        u = o.getUniformLocation(r, "u_noDataValue"),
        h = o.getUniformLocation(r, "u_clampLow"),
        d = o.getUniformLocation(r, "u_clampHigh"),
        m = o.getUniformLocation(r, "u_matrix");
      o.uniform2f(c, e.width, e.height),
        o.uniform2fv(n, this.domain),
        o.uniform2fv(s, this.displayRange),
        o.uniform1i(l, this.applyDisplayRange),
        o.uniform1i(h, this.clampLow),
        o.uniform1i(d, this.clampHigh),
        o.uniform1f(u, this.noDataValue),
        o.uniformMatrix3fv(m, !1, this.matrix);
      const g = o.createBuffer();
      o.bindBuffer(o.ARRAY_BUFFER, g),
        o.enableVertexAttribArray(i),
        o.vertexAttribPointer(i, 2, o.FLOAT, !1, 0, 0),
        setRectangle(o, 0, 0, e.width, e.height),
        o.drawArrays(o.TRIANGLES, 0, 6);
    } else if (this.ctx) {
      const a = this.ctx,
        r = e.width,
        o = e.height,
        i = a.createImageData(r, o),
        n = this.domain[1] - this.domain[0],
        s = this.colorScaleCanvas.width,
        l = this.colorScaleCanvas.getContext("2d").getImageData(0, 0, s, 1).data;
      let c;
      const u = t.data;
      for (let e = 0; e < o; e++)
        for (let t = 0; t < r; t++) {
          const a = e * r + t;
          let o = Math.floor(((u[a] - this.domain[0]) / n) * (s - 1));
          (c = 255),
            o < 0 ? ((o = 0), this.clampLow || (c = 0)) : o > 255 && ((o = 255), this.clampHigh || (c = 0)),
            (u[a] === this.noDataValue ||
              u[a] != u[a] ||
              (this.applyDisplayRange && (u[a] < this.displayRange[0] || u[a] >= this.displayRange[1]))) &&
              (c = 0);
          const h = 4 * (e * r + t);
          (i.data[h + 0] = l[4 * o]),
            (i.data[h + 1] = l[4 * o + 1]),
            (i.data[h + 2] = l[4 * o + 2]),
            (i.data[h + 3] = Math.min(c, l[4 * o + 3]));
        }
      a.putImageData(i, 0, 0);
    }
  }
  renderDataset(e) {
    return this.setCurrentDataset(e), this.render();
  }
  getColor(e) {
    const t = this.colorScaleCanvas.width,
      a = this.colorScaleCanvas.getContext("2d").getImageData(0, 0, t, 1).data,
      r = this.domain[1] - this.domain[0];
    let o = Math.round(((e - this.domain[0]) / r) * t),
      i = 255;
    return (
      o < 0 && ((o = 0), this.clampLow || (i = 0)),
      o > 255 && ((o = 255), this.clampHigh || (i = 0)),
      [a[4 * o], a[4 * o + 1], a[4 * o + 2], i]
    );
  }
  setExpression(e) {
    e && e.length ? (this.expressionAst = parseArithmetics(e)) : (this.expressionAst = null);
  }
}
export { plot, addColorScale, colorscales, renderColorScaleToCanvas };
//# sourceMappingURL=/sm/14881094125020173eb9804ad388dffaec7e9da28664bbb91d867df97164e992.map
