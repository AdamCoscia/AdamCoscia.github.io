<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cylinder Picker</title>
    <script src="libraries/d3.min.js"></script>
    <script src="libraries/jquery-3.6.0.min.js"></script>
    <script src="libraries/jquery.csv.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/geotiff"></script>
    <style>
      #plot-container {
        margin-right: 1rem;
        border: 4px solid lightgray;
        border-radius: 4px;
      }

      #grid-container {
        display: grid;
        gap: 10px 10px;
        grid-template-columns: repeat(3, 150px);
        grid-template-rows: repeat(auto-fit, minmax(20px, 30px));
        justify-items: stretch;
        align-items: stretch;
      }

      #grid-container h2 {
        margin: 0 auto;
      }

      .x-gridlines line,
      .y-gridlines line {
        stroke: #ddd;
      }

      .x-gridlines .tick,
      .y-gridlines .tick {
        opacity: 0.5;
      }

      .tooltip {
        position: absolute;
        text-align: center;
        width: 80px;
        height: 15px;
        padding: 2px;
        font: 12px sans-serif;
        background: lightsteelblue;
        border: 0px;
        border-radius: 8px;
        pointer-events: none;
      }

      .modal-mask {
        position: fixed;
        z-index: 9998;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        display: table;
        transition: opacity 0.3s ease;
      }

      .modal-wrapper {
        display: table-cell;
        vertical-align: middle;
      }

      .modal-container {
        width: 500px;
        margin: 0px auto;
        padding: 20px 30px;
        background-color: #fff;
        border-radius: 2px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.33);
        transition: all 0.3s ease;
        font-family: Helvetica, Arial, sans-serif;
      }

      .modal-header {
        margin-top: 0;
        font-size: 1.2rem;
        font-weight: 800;
        color: #42b983;
      }

      .modal-body {
        font-size: 0.8rem;
        margin: 20px 0;
      }

      .modal-footer {
        text-align: right;
      }

      .modal-enter {
        opacity: 0;
      }

      .modal-leave-active {
        opacity: 0;
      }

      .modal-enter .modal-container,
      .modal-leave-active .modal-container {
        -webkit-transform: scale(1.1);
        transform: scale(1.1);
      }
    </style>
  </head>

  <body>
    <div id="app">
      <!-- Containers -->
      <div style="display: flex">
        <!-- Holds the SVG -->
        <div id="plot-container"></div>

        <!-- Controls the SVG-->
        <div id="grid-container">
          <h2 style="grid-column: 1 /4">Inputs</h2>

          <span style="grid-column: 1; place-self: end center">Cruise</span>
          <span style="grid-column: 2; place-self: end center">Background</span>
          <span style="grid-column: 3; place-self: end center">Units</span>

          <select style="grid-column: 1" id="file-select">
            <option>Pescadero_final.csv</option>
            <option>SantaMonica_GeoChem_repeat.csv</option>
          </select>
          <select style="grid-column: 2" id="bg-select"></select>
          <select style="grid-column: 3" id="units-select">
            <option>Degrees</option>
            <!-- <option>Centimeters</option> -->
          </select>

          <span style="grid-column: 1; place-self: center right">Y max</span>
          <input style="grid-column: 2" type="text" id="y-max-input" />

          <span style="grid-column: 1; place-self: center right">Y min</span>
          <input style="grid-column: 2" type="text" id="y-min-input" />

          <input style="grid-column: 2" type="text" id="x-min-input" />
          <input style="grid-column: 3" type="text" id="x-max-input" />

          <span style="grid-column: 2; place-self: start center">X min</span>
          <span style="grid-column: 3; place-self: start center">X max</span>

          <button style="grid-column: 1 / 4" id="reset-btn">Reset</button>

          <h2 style="grid-column: 1 /4">Outputs</h2>

          <span style="grid-column: 1; place-self: center right">X Scale</span>
          <span style="grid-column: 2 / 4; place-self: center left" id="x-scale-output"></span>

          <span style="grid-column: 1; place-self: center right">Y Scale</span>
          <span style="grid-column: 2 / 4; place-self: center left" id="y-scale-output"></span>

          <span style="grid-column: 1 / 4; place-self: end center" id="cylinder-output-title">Cylinders (0):</span>
          <span style="grid-column: 1 / 4; justify-self: center" id="cylinder-output">No file loaded.</span>
        </div>
      </div>

      <!-- Modal -->

      <div id="modal" class="modal-mask">
        <div class="modal-wrapper">
          <div class="modal-container">
            <div class="modal-header">Instructions</div>
            <div class="modal-body">
              <span>1. Click and drag on the plot to zoom in on the highlighted region.</span>
              <br /><br />
              <span>2. The currently visible cylinders will be displayed in a list to the right of the plot.</span>
              <br /><br />
              <span>3. Hover on a dot in the plot to see the cylinder name.</span>
              <br /><br />
              <span>4. Click reset to return the plot to it's original axis limits.</span>
              <br /><br />
              <span>5. Change the cruise data, background image, and units at the top right</span>
            </div>
            <div class="modal-footer">
              <button id="hide-modal-btn">OK</button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script type="module">
      const BACKGROUNDS = {
        "Pescadero_final.csv": [
          "Auka_LASSmb_Topo5cm_slope3710-3630",
          // "Auka_Lidar_Topo2cm_slope3710-3630",
          "Auka_Pmos_LeftRaw_5cm",
          "MAUV_SoPB_TopoSq_1m_slope3796-3334",
        ],
        "SantaMonica_GeoChem_repeat.csv": [],
      };

      let plotGroup,
        bgGroup,
        marksGroup,
        xScale,
        xAxis,
        xAxisGroup,
        yScale,
        yAxis,
        yAxisGroup,
        xGridlinesGroup,
        yGridlinesGroup;

      // get layout
      let width = window.innerWidth - 24;
      let height = window.innerHeight - 60;
      let svgWidth = height;
      let svgHeight = height;

      // set plot margins, width and height
      let plotMargins = { top: 20, bottom: 50, left: 80, right: 20 };
      let plotWidth = svgWidth - plotMargins.left - plotMargins.right;
      let plotHeight = svgHeight - plotMargins.top - plotMargins.bottom;

      // make svg
      let svg = d3
        .select("#plot-container")
        .append("svg")
        .attr("id", "svg")
        .attr("width", svgWidth)
        .attr("height", svgHeight);

      // define data object
      let data = {
        file: `data/${$("#file-select").find(":selected").text()}`,
        points: [],
        extent: {
          x: [0, 100],
          y: [0, 100],
        },
        filter: {
          x: [0, 100],
          y: [0, 100],
        },
      };

      // variables to be plotted on the x and y axes
      let xVar, yVar;
      let unit = $("#units-select").find(":selected").text();
      switch (unit) {
        case "Degrees":
          xVar = "Longitude_deg";
          yVar = "Latitude_deg";
          break;
        case "Centimeters":
          xVar = "Longitude_rel_cm";
          yVar = "Latitude_rel_cm";
          break;
      }

      // populate the background select list based on the cruise selected
      const el = $("#bg-select").get(0);
      while (el.options.length > 0) {
        el.remove(el.options.length - 1);
      }
      const newOpts = BACKGROUNDS[$("#file-select").find(":selected").text()];
      for (let i = 0; i < newOpts.length; i++) {
        const opt = document.createElement("option");
        opt.text = newOpts[i];
        el.add(opt, null);
      }

      // define background image files
      let bg = {
        name: $("#bg-select").find(":selected").text(),
        png: `data/${$("#bg-select").find(":selected").text()}.png`,
        json: `data/${$("#bg-select").find(":selected").text()}.json`,
        tif: `data/${$("#bg-select").find(":selected").text()}.tif`,
        meta: undefined,
      };

      // update inputs
      $("#x-min-input").val(data.filter["x"][0]);
      $("#x-max-input").val(data.filter["x"][1]);
      $("#y-min-input").val(data.filter["y"][0]);
      $("#y-max-input").val(data.filter["y"][1]);

      // set the event listeners
      $("#file-select").on("change", setNewData);
      $("#bg-select").on("change", setNewBG);
      $("#units-select").on("change", setNewData);
      $("#reset-btn").on("click", resetPointsFilter);
      $("#x-min-input").on("change", setPointsFilter);
      $("#x-max-input").on("change", setPointsFilter);
      $("#y-min-input").on("change", setPointsFilter);
      $("#y-max-input").on("change", setPointsFilter);
      $("#hide-modal-btn").on("click", hideModal);

      // init, load data, load GeoTIFF meta, draw
      init();
      loadFile(data.file).then(loadData);

      function init() {
        // add loading text
        svg.append("text").attr("id", "loading-text").attr("dy", "1em").html("Loading data ...");

        // Add plot group, containing axes, marks, and legend
        plotGroup = svg
          .append("g")
          .classed("plot", true)
          .attr("transform", `translate(${plotMargins.left},${plotMargins.top})`);

        // add background group and elevation background
        if (bg.name) {
          bgGroup = plotGroup.append("g").classed("bg", true);
          bgGroup
            .append("svg")
            .attr("width", plotWidth)
            .attr("height", plotHeight)
            .append("svg:image")
            .attr("preserveAspectRatio", "none")
            .attr("xlink:href", bg.png);
        }

        // Add X and Y axis groups
        yAxisGroup = plotGroup.append("g").classed("y", true).classed("axis", true);
        xAxisGroup = plotGroup
          .append("g")
          .classed("x", true)
          .classed("axis", true)
          .attr("transform", `translate(${0},${plotHeight})`);

        // add gridlines groups
        xGridlinesGroup = plotGroup.append("g").classed("x-gridlines", true);
        yGridlinesGroup = plotGroup.append("g").classed("y-gridlines", true);

        // Add data marks group
        marksGroup = plotGroup.append("g").classed("marks", true);

        // Add drag region to marks group
        let dragRegion = marksGroup
          .append("rect")
          .attr("width", plotWidth)
          .attr("height", plotHeight)
          .style("opacity", 0);

        // define the selection rectangle
        let selectionRect = {
          element: null,
          previousElement: null,
          currentY: 0,
          currentX: 0,
          originX: 0,
          originY: 0,
          init: function (newX, newY) {
            let rectElement = marksGroup
              .append("rect")
              .attr("x", 0)
              .attr("y", 0)
              .attr("width", 0)
              .attr("height", 0)
              .attr("rx", 4)
              .attr("ry", 4)
              .attr("stroke", "#545454")
              .attr("stroke-width", "2px")
              .attr("stroke-opacity", "1")
              .attr("fill", "white")
              .attr("fill-opacity", "0.5")
              .classed("selection", true);
            this.setElement(rectElement);
            this.originX = newX;
            this.originY = newY;
            this.update(newX, newY);
          },
          update: function (newX, newY) {
            this.currentX = newX;
            this.currentY = newY;
            let x = this.currentX < this.originX ? this.currentX : this.originX;
            let y = this.currentY < this.originY ? this.currentY : this.originY;
            let width = Math.abs(this.currentX - this.originX);
            let height = Math.abs(this.currentY - this.originY);
            this.element.attr("x", x).attr("y", y).attr("width", width).attr("height", height);
          },
          setElement: function (ele) {
            this.previousElement = this.element;
            this.element = ele;
          },
          remove: function () {
            this.element.remove();
            this.element = null;
          },
          removePrevious: function () {
            if (this.previousElement) {
              this.previousElement.remove();
            }
          },
          getCurrentAttributes: function () {
            let x = +this.element.attr("x");
            let y = +this.element.attr("y");
            let width = +this.element.attr("width");
            let height = +this.element.attr("height");
            return {
              x1: x,
              y1: y,
              x2: x + width,
              y2: y + height,
            };
          },
        };

        let dragStart = function (e) {
          selectionRect.init(e.x, e.y);
          selectionRect.removePrevious();
        };

        let dragMove = function (e) {
          let newX = e.x < 0 ? 0 : e.x > plotWidth ? plotWidth : e.x;
          let newY = e.y < 0 ? 0 : e.y > plotHeight ? plotHeight : e.y;
          selectionRect.update(newX, newY);
        };

        let dragEnd = function () {
          let attrs = selectionRect.getCurrentAttributes();
          selectionRect.remove();
          if (attrs.x2 - attrs.x1 > 1 && attrs.y2 - attrs.y1 > 1) {
            data.filter["x"][0] = xScale.invert(attrs.x1);
            data.filter["x"][1] = xScale.invert(attrs.x2);
            data.filter["y"][0] = yScale.invert(attrs.y2);
            data.filter["y"][1] = yScale.invert(attrs.y1);
            $("#x-min-input").val(xScale.invert(attrs.x1));
            $("#x-max-input").val(xScale.invert(attrs.x2));
            $("#y-min-input").val(yScale.invert(attrs.y2));
            $("#y-max-input").val(yScale.invert(attrs.y1));
            draw(); // update the vis
          }
        };

        let dragBehavior = d3.drag().on("start", dragStart).on("drag", dragMove).on("end", dragEnd);
        dragRegion.call(dragBehavior);
      }

      async function loadFile(url) {
        const res = await fetch(url);
        return res.text();
      }

      function loadData(contents) {
        // read the csv
        $.csv.toObjects(contents, {}, (err, points) => {
          if (err) {
            console.log(err);
          }
          // set initial filter to first point
          const p = points[0];
          data.filter["x"][0] = p[xVar];
          data.filter["x"][1] = p[xVar];
          data.filter["y"][0] = p[yVar];
          data.filter["y"][1] = p[yVar];
          data.points.push(p);
          // collect points
          for (let i = 1, len = points.length; i < len; i++) {
            const p = points[i];
            data.filter["x"][0] = Math.min(data.filter["x"][0], p[xVar]);
            data.filter["x"][1] = Math.max(data.filter["x"][1], p[xVar]);
            data.filter["y"][0] = Math.min(data.filter["y"][0], p[yVar]);
            data.filter["y"][1] = Math.max(data.filter["y"][1], p[yVar]);
            data.points.push(p);
          }
        });
        // update inputs and extent
        data.extent["x"][0] = data.filter["x"][0];
        data.extent["x"][1] = data.filter["x"][1];
        data.extent["y"][0] = data.filter["y"][0];
        data.extent["y"][1] = data.filter["y"][1];
        $("#x-min-input").val(data.filter["x"][0]);
        $("#x-max-input").val(data.filter["x"][1]);
        $("#y-min-input").val(data.filter["y"][0]);
        $("#y-max-input").val(data.filter["y"][1]);
        // load the GeoTIFF meta data, then finally draw the image!
        if (bg.name) {
          loadBGMeta().then(draw);
        } else {
          draw();
        }
      }

      async function loadBGMeta() {
        // const url = "https://dl.dropboxusercontent.com/s/32kx8uk33e9dr21/Auka_LASSmb_Topo5cm_slope3710-3630.tif?dl=0";
        // const tiff = await fetch(bg.tif).then((response) =>
        //   response.arrayBuffer().then((buffer) => GeoTIFF.fromArrayBuffer(buffer))
        // );
        // const image = await tiff.getImage();
        // bg.meta = {
        //   width: image.getWidth(),
        //   height: image.getHeight(),
        //   tileWidth: image.getTileWidth(),
        //   tileHeight: image.getTileHeight(),
        //   samplesPerPixel: image.getSamplesPerPixel(),
        //   origin: image.getOrigin(),
        //   resolution: image.getResolution(),
        //   bbox: image.getBoundingBox(),
        // };
        bg.meta = await fetch(bg.json).then((response) => response.text().then((contents) => JSON.parse(contents)));
        return bg.meta;
      }

      function hideModal() {
        $("#modal").hide();
      }

      function setNewBG() {
        // define background image files
        bg = {
          name: $("#bg-select").find(":selected").text(),
          png: `data/${$("#bg-select").find(":selected").text()}.png`,
          json: `data/${$("#bg-select").find(":selected").text()}.json`,
          tif: `data/${$("#bg-select").find(":selected").text()}.tif`,
          meta: undefined,
        };
        // clear out svg
        svg.selectAll("*").remove();
        // re-initialize svg and load new data
        init();
        if (bg.name) {
          loadBGMeta().then(draw);
        } else {
          draw();
        }
      }

      function setNewData() {
        // reset data
        data = {
          file: `data/${$("#file-select").find(":selected").text()}`,
          points: [],
          extent: {
            x: [0, 100],
            y: [0, 100],
          },
          filter: {
            x: [0, 100],
            y: [0, 100],
          },
        };
        // variables to be plotted on the x and y axes
        unit = $("#units-select").find(":selected").text();
        switch (unit) {
          case "Degrees":
            xVar = "Longitude_deg";
            yVar = "Latitude_deg";
            break;
          case "Centimeters":
            xVar = "Longitude_rel_cm";
            yVar = "Latitude_rel_cm";
            break;
        }
        // populate the background select list based on the cruise selected
        const el = $("#bg-select").get(0);
        while (el.options.length > 0) {
          el.remove(el.options.length - 1);
        }
        const newOpts = BACKGROUNDS[$("#file-select").find(":selected").text()];
        for (let i = 0; i < newOpts.length; i++) {
          const opt = document.createElement("option");
          opt.text = newOpts[i];
          el.add(opt, null);
        }
        // define background image files
        bg = {
          name: $("#bg-select").find(":selected").text(),
          png: `data/${$("#bg-select").find(":selected").text()}.png`,
          json: `data/${$("#bg-select").find(":selected").text()}.json`,
          tif: `data/${$("#bg-select").find(":selected").text()}.tif`,
          meta: undefined,
        };
        // clear out svg
        svg.selectAll("*").remove();
        // update inputs
        $("#x-min-input").val(data.filter["x"][0]);
        $("#x-max-input").val(data.filter["x"][1]);
        $("#y-min-input").val(data.filter["y"][0]);
        $("#y-max-input").val(data.filter["y"][1]);
        // re-initialize svg and load new data
        init();
        loadFile(data.file).then(loadData);
      }

      function resetPointsFilter() {
        data.filter["x"][0] = data.extent["x"][0];
        data.filter["x"][1] = data.extent["x"][1];
        data.filter["y"][0] = data.extent["y"][0];
        data.filter["y"][1] = data.extent["y"][1];
        $("#x-min-input").val(data.extent["x"][0]);
        $("#x-max-input").val(data.extent["x"][1]);
        $("#y-min-input").val(data.extent["y"][0]);
        $("#y-max-input").val(data.extent["y"][1]);
        draw();
      }

      function setPointsFilter() {
        // x-min
        data.filter["x"][0] = parseFloat($("#x-min-input").val());
        if (data.filter["x"][0] < data.extent["x"][0]) data.filter["x"][0] = data.extent["x"][0];
        if (data.filter["x"][0] > data.filter["x"][1]) data.filter["x"][0] = data.filter["x"][1] - 1;
        $("#x-min-input").val(data.filter["x"][0]);
        // x-max
        data.filter["x"][1] = parseFloat($("#x-max-input").val());
        if (data.filter["x"][1] < data.filter["x"][0]) data.filter["x"][1] = data.filter["x"][0] + 1;
        if (data.filter["x"][1] > data.extent["x"][1]) data.filter["x"][1] = data.extent["x"][1];
        $("#x-max-input").val(data.filter["x"][1]);
        // y-min
        data.filter["y"][0] = parseFloat($("#y-min-input").val());
        if (data.filter["y"][0] < data.extent["y"][0]) data.filter["y"][0] = data.extent["y"][0];
        if (data.filter["y"][0] > data.filter["y"][1]) data.filter["y"][0] = data.filter["y"][1] - 1;
        $("#y-min-input").val(data.filter["y"][0]);
        // y-max
        data.filter["y"][1] = parseFloat($("#y-max-input").val());
        if (data.filter["y"][1] < data.filter["y"][0]) data.filter["y"][1] = data.filter["y"][0] + 1;
        if (data.filter["y"][1] > data.extent["y"][1]) data.filter["y"][1] = data.extent["y"][1];
        $("#y-max-input").val(data.filter["y"][1]);
        // re-draw the vis
        draw();
      }

      function draw() {
        if (!data.points) return; // if there's no dataset don't update the scatter plot

        svg.select("#loading-text").remove(); // remove loading text

        // create list of data data.points
        let rawData = data.points.map((dataPoint) => {
          return {
            ...dataPoint,
            xVar: dataPoint[xVar],
            yVar: dataPoint[yVar],
          };
        });

        // filter list of data points
        let prepared = rawData.filter((dataPoint) => {
          return (
            dataPoint[xVar] >= data.filter["x"][0] &&
            dataPoint[xVar] <= data.filter["x"][1] &&
            dataPoint[yVar] >= data.filter["y"][0] &&
            dataPoint[yVar] <= data.filter["y"][1]
          );
        });

        // output extents formatted
        let xDiff, yDiff;
        switch (unit) {
          case "Degrees":
            xDiff = (data.filter["x"][1] - data.filter["x"][0]) * (1.11 / 10 ** -7); // convert to cm
            yDiff = (data.filter["y"][1] - data.filter["y"][0]) * (1.11 / 10 ** -7); // convert to cm
            break;
          case "Centimeters":
            xDiff = data.filter["x"][1] - data.filter["x"][0]; // already in cm
            yDiff = data.filter["y"][1] - data.filter["y"][0]; // already in cm
            break;
        }
        $("#x-scale-output").html(`${Math.round((xDiff + Number.EPSILON) * 100) / 100}cm`);
        $("#y-scale-output").html(`${Math.round((yDiff + Number.EPSILON) * 100) / 100}cm`);

        // get unique cylinder names plotted
        let unique = [...new Set(prepared.map((d) => d.Cylinder))];
        $("#cylinder-output-title").html(`Cylinders (${unique.length}):`);
        if (unique.length > 0) {
          $("#cylinder-output").html(`[${unique.map((name) => `"${name}"`).join(",\n  ")}\n]`);
        } else {
          $("#cylinder-output").html("None visible. To zoom out, press the Reset button.");
        }

        // Create scales and axes based on vis matrix
        let xAxisTitle, yAxisTitle;
        switch (unit) {
          case "Degrees":
            xAxisTitle = "Longitude (decimal degrees)";
            yAxisTitle = "Latitude (decimal degrees)";
            break;
          case "Centimeters":
            xAxisTitle = "Relative Longitude (cm)";
            yAxisTitle = "Relative Latitude (cm)";
            break;
        }

        // set scales
        xScale = d3.scaleLinear().domain(data.filter["x"]).range([0, plotWidth]);
        yScale = d3.scaleLinear().domain(data.filter["y"]).range([plotHeight, 0]);

        // set axes
        xAxis = d3.axisBottom(xScale);
        yAxis = d3.axisLeft(yScale);

        // draw axes
        xAxisGroup.call(xAxis);
        yAxisGroup.call(yAxis);

        // draw axis titles
        xAxisGroup.select(".x.axis.title").remove();
        xAxisGroup
          .append("g")
          .classed("x axis title", true)
          .attr("opacity", 1)
          .attr("transform", `translate(${plotWidth / 2}, 0)`)
          .append("text")
          .attr("text-anchor", "middle")
          .attr("fill", "currentColor")
          .attr("dy", "4.5em")
          .text(xAxisTitle);
        yAxisGroup.select(".y.axis.title").remove();
        yAxisGroup
          .append("g")
          .classed("y axis title", true)
          .attr("opacity", 1)
          .attr("transform", `translate(-45, ${plotHeight / 2})`)
          .append("text")
          .attr("fill", "currentColor")
          .text(yAxisTitle);

        // prepare data labels for yAxis
        yAxisGroup
          .selectAll("text")
          .style("text-anchor", "middle")
          .attr("dx", "0.8em")
          .attr("dy", "-1.21em")
          .attr("transform", "rotate(-90)");

        // stagger every other tick label
        xAxisGroup.selectAll(".tick").each(function (_, i) {
          if (i % 2 !== 0) {
            d3.select(this).select("line").attr("y2", 15);
            d3.select(this).select("text").attr("dy", "1.91em");
          }
        });
        yAxisGroup.selectAll(".tick").each(function (_, i) {
          if (i % 2 !== 0) {
            d3.select(this).select("line").attr("x2", -15);
            d3.select(this).select("text").attr("dy", "-2.41em");
          }
        });

        // add gridlines
        let xGridlines = d3.axisTop().tickFormat("").tickSize(-plotHeight).scale(xScale);
        xGridlinesGroup.select("*").remove();
        xGridlinesGroup.call(xGridlines).call((g) => g.select(".domain").remove());
        let yGridlines = d3.axisRight().tickFormat("").tickSize(plotWidth).scale(yScale);
        yGridlinesGroup.select("*").remove();
        yGridlinesGroup.call(yGridlines).call((g) => g.select(".domain").remove());

        // Define the div for the tooltip
        let div = d3.select("body").append("div").attr("class", "tooltip").style("opacity", 0);

        // JOIN data selection using Primary Key label
        let dataBound = marksGroup.selectAll(".post").data(prepared);

        // DELETE extra data.points
        dataBound.exit().remove();

        // ENTER new data.points (starting invisible, later fade them in)
        let enterSelection = dataBound.enter().append("g").classed("post", true);

        // UPDATE all existing data.points
        enterSelection.append("circle");
        enterSelection
          .merge(dataBound)
          .select("circle")
          .attr("transform", (d) => `translate(${xScale(d["xVar"])},${yScale(d["yVar"])})`)
          .attr("r", 6)
          .style("fill", "white")
          .style("fill-opacity", 0.8)
          .style("stroke-width", "1px")
          .style("stroke", "black")
          .style("cursor", "pointer")
          .on("mouseover", function (e, d) {
            div.transition().duration(200).style("opacity", 0.9);
            div
              .html(d.Cylinder)
              .style("left", e.x + "px")
              .style("top", e.y - 28 + "px");
          })
          .on("mouseout", function () {
            div.transition().duration(500).style("opacity", 0);
          });

        // finally update the background PNG
        if (bg.name) {
          bgGroup
            .select("image")
            .attr("x", xScale(bg.meta.origin[0]))
            .attr("y", yScale(bg.meta.origin[1]))
            .attr("width", xScale(bg.meta.bbox[2]) - xScale(bg.meta.bbox[0]))
            .attr("height", yScale(bg.meta.bbox[1]) - yScale(bg.meta.bbox[3]));
        }
      }
    </script>
  </body>
</html>
